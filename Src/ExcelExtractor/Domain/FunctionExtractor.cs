using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Algorithms;
using ExcelInterop;
using ExcelInterop.Domain;
using LinqExtensions.Extensions;
using NCalcExcel;

namespace ExcelExtractor.Domain {
    /// <summary>
    /// This class is a controller for all of the extractors running, it collates all the data they extract
    /// </summary>
    public class FunctionExtractor {
        private static readonly log4net.ILog Log = log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        public readonly ExpressionFactory ExpressionFactory;
        public readonly string ExcelFile;
        private readonly int _numThreads;
        private readonly Func<string, IExcelReader> _readerFactory;

        public ConcurrentStack<string> CellsToExtract { get; private set; }
        public Action OnFinish;
        public Semaphore RunningTasks;

        /// <summary>
        /// Contains unique list of processed cells indexed by their Sheet!RC address
        /// </summary>
        public ConcurrentDictionary<string, ExtractedCell> ProcessedCells = new ConcurrentDictionary<string, ExtractedCell>();

        /// <summary>
        /// Contains map of ways to reference a cell together with the cell...
        /// </summary>
        public readonly ConcurrentDictionary<string, ExtractedCell> MappedProcessedCells = new ConcurrentDictionary<string, ExtractedCell>();

        public ExtractedCell Root;

        public bool HaveEvaluted = false;
        public ConcurrentDictionary<string, ExtractedCell> Evaluations;
        public readonly List<Tuple<string, string>> Shims;
        public string RootCell;

        /// <summary>
        /// stores graph generated by references during evaluation
        /// </summary>
        public ConcurrentDictionary<ExtractedCell, List<ExtractedCell>> EvaluationGraph =
            new ConcurrentDictionary<ExtractedCell, List<ExtractedCell>>();

        public FunctionExtractor(ExpressionFactory expressionFactory, string excelFile,
            List<Tuple<string, string>> shims, int threads, Func<string, IExcelReader> readerFactory) {
            this.ExpressionFactory = expressionFactory;
            this.ExcelFile = excelFile;
            this.Shims = shims;
            this._numThreads = threads;
            this._readerFactory = readerFactory;
        }

        public void BeginExtractionFrom(string excelAddress, Action onFinish) {
            BeginExtractionFrom(new List<string> {excelAddress},onFinish );
        }

        public void BeginExtractionFrom(List<string> excelAddress, Action onFinish) {

            this.CellsToExtract = new ConcurrentStack<string>();
            this.OnFinish = onFinish;
            Log.Info("Starting Extraction with " + _numThreads + "threads");

            foreach (var address in excelAddress) {
                this.CellsToExtract.Push(address);
            }
            
            this.RootCell = excelAddress.First();
            this.RunningTasks = new Semaphore(0, _numThreads);

            // set up continuation task
            Task.Factory.StartNew(() => {
                for (int i = 1; i <= _numThreads; i++) {
                    this.RunningTasks.WaitOne();
                }
                RunPostProcessing();
                onFinish.Invoke();
            });
            // start off the workers!
            Task.Factory.StartNew(() => {
                Parallel.For(0, _numThreads, id => {
                    var extr = new Extractor(this, _readerFactory);
                    extr.StartExtraction();
                });
            });
        }

        public void AddWorkItem(string reference) {
            // if its not done
            if (this.ProcessedCells.ContainsKey(reference) || this.MappedProcessedCells.ContainsKey(reference)) {
                return;
            }

            if (reference.Contains("1000") && reference.Contains("LU_")) {
                Log.Error("found nasty reference...");
            }

            // add it to the queue - we hope it doesn't get added ten times!
            this.CellsToExtract.Push(reference);
        }

        public void AddNewProcessedCell(ExtractedCell extractedCell) {
            if (this.ProcessedCells.TryAdd(extractedCell.ToString(), extractedCell)) {
                // its a newly processed cell so we must deal with it 
                this.MappedProcessedCells.TryAdd(extractedCell.ToString(), extractedCell);

                foreach (var excelName in extractedCell.ExcelNames) {
                    this.MappedProcessedCells.TryAdd(excelName, extractedCell);
                }
            }
        }

        private void RunPostProcessing() {
            Log.Info("Finished Extraction ... now post processing");

            // set up the references correctly)
            foreach (var cell in ProcessedCells) {
                foreach (var reference in cell.Value.References) {
                    reference.Cell = this.MappedProcessedCells[reference.Tagname.ToString()];
                }
            }
        }

        public object Evaluate(string cellName) {
            if (!HaveEvaluted) {
                EvaluateAll();
            }
            return this.ProcessedCells[cellName].EvaluatedValue;
        }

        public void EvaluateAll() {
            Log.Info("Beginning Evaluate All");

            // turn off debug mode
            if ((this.ExpressionFactory.Options & EvaluateOptions.DebugMode) == EvaluateOptions.DebugMode) {
                this.ExpressionFactory.Options &= ~EvaluateOptions.DebugMode;
            }

            //clear previous results
            foreach (var cell in ProcessedCells) {
                cell.Value.EvaluatedValue = null;
                cell.Value.IsEvaluated = false;
            }

            // prep evaluation graph
            EvaluationGraph = new ConcurrentDictionary<ExtractedCell, List<ExtractedCell>>();

            //prep work
            var cellsToEval = this.ProcessedCells.ToDictionary(c => c.Key, c => c.Value);

            // and eval it with a worklist

            ConcurrentDictionary<string, ExtractedCell> res =
                WorkList.ParallelRecursiveEvalDebug<string, ExtractedCell, ExtractedCell>(cellsToEval,
                    Evaluator, cell => cell.ToString()+"="+cell.Formula );

            this.Evaluations = res;
            Log.Info("Finished Evaluate All");
            this.HaveEvaluted = true;
        }

        private string Evaluator(KeyValuePair<string, ExtractedCell> cell,
            ConcurrentDictionary<string, ExtractedCell> evaluatedCells) {
            try {
                if (cell.Key == "LU_C1!B55") {
                    Log.Debug("entering Debug");
                }

                if (cell.Value.IsRange) {
                    if (!cell.Value.ExpandRange().All(r => evaluatedCells.ContainsKey(r.ToString()))) {
                        return "A Range who's cells have not all be evaluated";
                    }

                    cell.Value.RangeIsFullyEvaluated = true;
                }

                if (!cell.Value.References.All(reference => reference.Cell.IsEvaluated)) {
                    return
                        "A formula where not all cells have been evaluted"; // somethings we reference have not been evaluated yet...
                }

                List<CellReference> cellRanges = cell.Value.References.Where(r => r.Cell.IsRange).ToList();
                if (cellRanges.Any()) {
                    if (!cellRanges.All(r => r.Cell.RangeIsFullyEvaluated)) {
                        return cellRanges.Aggregate("a formula where a range it references has not been evaluated",
                            (acc, next) => acc + " " + next.ToString());
                    }
                }

                // create a dictionary of references.. 
                Dictionary<string, Tuple<ExtractedCell, object>> parameters =
                    cell.Value.References.ToDictionary(cr => cr.KnownbyParentAs,
                        cr => new Tuple<ExtractedCell, object>(cr.Cell,
                            HydrateValue(cr.Cell.EvaluatedValue, EvaluateOptions.None)));
                foreach (var cellref in cell.Value.References.Where(c => c.Cell.IsRange)) {
                    foreach (var cellAddress in cellref.Cell.ExpandRange()) {
                        var evaluatedCell =
                            evaluatedCells[
                                cellAddress.ToString()]; // todo this may not always be how the cell is referred to
                        parameters.Add(cellAddress.ToString(),
                            new Tuple<ExtractedCell, object>(evaluatedCell,
                                HydrateValue(evaluatedCell.EvaluatedValue, EvaluateOptions.None)));
                    }
                }

                // including info on whether or not each of these references is blank or not... 
                foreach (var reference in cell.Value.References) {
                    parameters.Add("A_BLANK_A" + reference.KnownbyParentAs,
                        new Tuple<ExtractedCell, object>(reference.Cell, reference.Cell.IsBlank));
                }

                // generate the actual formula - not that this generally returns a wrapped reference to a parameter which actually contains the formula. e.g. (FormulaA1) 
                string formula = cell.Value.GenerateFormula(parameters);

                // moving parameters into the events to catch them and add to list below:
                List<ExtractedCell> cellsUsedInCalculation = new List<ExtractedCell>();

                // now eval it
                var value = this.ExpressionFactory.Evaluate(formula, new Dictionary<string, object>(),
                    delegate(string name, ParameterArgs args) {
                        if (parameters.ContainsKey(name)) {
                            args.Result = parameters[name].Item2; // eval'd value
                            args.HasResult = true;
                            cellsUsedInCalculation.AddIfNotExistant(parameters[name].Item1);
                            return;
                        }

                        string lookupname = name;
                        bool containsblank = false; // see if we are querying whether a cells is blank or not
                        if (name.StartsWith("A_BLANK_A")) {
                            containsblank = true;
                            lookupname = name.Replace("A_BLANK_A", "");
                        }

                        // check if we are referencing a cell we know about
                        CellReference reference =
                            cell.Value.References.FirstOrDefault(refr => refr.KnownbyParentAs.Equals(lookupname));
                        if (reference != null) {
                            ExtractedCell extractedCell = evaluatedCells[reference.Cell.ToString()];
                            args.Result = containsblank
                                ? extractedCell.IsBlank
                                : extractedCell.EvaluatedValue;

                            cellsUsedInCalculation.AddIfNotExistant(extractedCell);

                            args.HasResult = true;
                        }
                        else {
                            // ideally this code should NEVER be called except by references..., if it is it indicates that a function has not estimated the cells it may reference correctly.
                            // or a range has not been expanded! 
                            if (evaluatedCells.ContainsKey(lookupname)) {
                                Log.Error(" ref= " + cell.Key + " formula= " + cell.Value.Formula +
                                          " could not find a cell " + lookupname + " as it has not been evaluated yet");
                            }

                            ExtractedCell extractedCell = evaluatedCells[lookupname];
                            args.Result = containsblank
                                ? extractedCell.IsBlank
                                : extractedCell.EvaluatedValue;
                            cellsUsedInCalculation.AddIfNotExistant(extractedCell);

                            args.HasResult = true;
                        }

                        if (args.HasResult) {
                            args.Result = HydrateValue(args.Result, args.Options);
                        }
                    });

                cell.Value.SetEvaluatedValue(value);
                // finally test we are correct!
                if (!cell.Value.IsRange) {
                    if (!ExcelEqualityComparison.ResultsAreEqual(cell.Value.EvaluatedValue.ToString(), cell.Value.Value)) {
                        Log.Error(
                            $"({evaluatedCells.Count}) Evaluation failure Expected '{cell.Value.Value}' received '{cell.Value.EvaluatedValue}' for formula {cell.Value.Formula}");
                    }
                }
                // store a list of the cells we actually referenced on this eval  

                PostProcessCellsUsedInCalculation(cell.Value, cellsUsedInCalculation);

                EvaluationGraph.TryAdd(cell.Value, cellsUsedInCalculation);

                // and add the cell to the list of evaluated cells
                if (evaluatedCells.Count % 100 == 0) {
                    Log.Info("Total Cells Evaluted " + evaluatedCells.Count);
                }

                return evaluatedCells.TryAdd(cell.Key, cell.Value) ? null : "double evaluation??";
            }
            catch (Exception e) {
                Log.Error("Exception " + e);
                return "exception ";
            }
        }

        /// <summary>
        /// Posts processes cells used in calculation.
        /// Goal here is to decrease the number of arcs in a sensible way.
        /// </summary>
        /// <param name="currentCell">The current cell.</param>
        /// <param name="cellsUsedInCalculation">The cells used in calculation.</param>
        /// <param name="replaceAllLinksWhereRangeReferenced">if set to <c>true</c> for each range referenced - if all the cells in the range are referenced then remove those links and just leave the range reference.</param>
        private static void PostProcessCellsUsedInCalculation(ExtractedCell currentCell,
                                                              List<ExtractedCell> cellsUsedInCalculation,
                                                              bool replaceAllLinksWhereRangeReferenced = true) {
            List<ExtractedCell> toRemove = new List<ExtractedCell>();

            if (replaceAllLinksWhereRangeReferenced) {
                if (!currentCell.IsRange) {
                    var ranges =
                        (from range in cellsUsedInCalculation
                         where range.IsRange
                         let cellsinRange = from reference in range.References select reference.Cell
                         where cellsinRange.All(cellsUsedInCalculation.Contains)
                         select new Tuple<ExtractedCell, IEnumerable<ExtractedCell>>(range, cellsinRange)
                        );
                    foreach (var range in ranges) {
                        range.Item1.RangeIsFullyEvaluated = true;// everything in this range has been evaluated so we know the range is 
                        //Log.Debug("Range is fully referenced: " + range.Item1);
                        toRemove.AddRange(range.Item2);
                    }
                }
            }


            foreach (var extractedCell in toRemove) {
                cellsUsedInCalculation.Remove(extractedCell);
            }
        }

        private static object HydrateValue(object value, EvaluateOptions argsOptions) {
            if (value is double || value is bool || value is decimal) {
                return value;
            } else {
                string valuestr = value.ToString();
                if (!argsOptions.HasFlag(EvaluateOptions.DonotHydrateBlanksToZero)) {
                    if (valuestr.Equals("\"\"")) {
                        return 0.0;
                            // by virtue of   a magic excelbug where referenced empty cells magically have value 0 
                        //  this is now causing problems with lookup's erroneously matching a zero... - hence the look ups set this flag when they need to
                    }
                }
                if (valuestr.Equals("'TRUE'")) {
                    return true;
                }

                if (valuestr.Equals("'FALSE'")) {
                    return false;
                }

                if (bool.TryParse(valuestr, out var resbool)) {
                    return resbool;
                }
               /* double resdouble;
                if (double.TryParse(valuestr,out resdouble)) {
                    return resdouble;
                }*/
                if (decimal.TryParse(valuestr, out var resdecimal)) {
                    return resdecimal;
                }                
            }

            return value.ToString();// a guess!
        }

        public ExtractionResults ReturnExtractedTree() {
            return new ExtractionResults() {ProcessedCells = this.ProcessedCells.Values.ToList(), rootCell = RootCell};
        }

        public XElement GetRootXML() {            
            // set up tree...
            this.Root = this.MappedProcessedCells[this.RootCell];
            return Root.ToXml();
            
        }

        public string GetCellsAsTSV(bool? isRange = null, bool? hasReferences = null, bool? isBlank = null, bool? isNumeric = null) {            
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("cellName\tSheet\tColumn\tRow\tisBlank\tisFormula\tisRange\tFormula\tNum_References\tValue\tExcelNames\tIsEvaluated\tEvaluatedValue");
            IEnumerable<ExtractedCell> cells = this.ProcessedCells.Values.AsEnumerable();

            if (isRange != null) {
                if ((bool) isRange) {
                    cells = cells.Where(cell => cell.IsRange);
                } else {
                    cells = cells.Where(cell => !cell.IsRange);
                }
            }

            if (hasReferences != null) {
                if ((bool)hasReferences) {
                    cells = cells.Where(cell => cell.References.Count> 0);
                } else {
                    cells = cells.Where(cell => cell.References.Count == 0);
                }
            }

            if (isBlank != null) {
                if ((bool)isBlank) {
                    cells = cells.Where(cell => cell.IsBlank);
                } else {
                    cells = cells.Where(cell => !cell.IsBlank);
                }
            }

            if (isNumeric != null) {
                if ((bool)isNumeric) {
                    cells = cells.Where(cell => {
                                            decimal d;
                                            return decimal.TryParse(cell.Value, out d);
                                        });
                } else {
                    cells = cells.Where(cell => {
                        decimal d;
                        return !decimal.TryParse(cell.Value, out d);
                    });
                }
            }

            cells = cells.OrderBy(cell => cell.ToString());

            foreach (var cell in cells) {
                var addr = new ExcelAddress(cell.ToString());
                sb.AppendLine(string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\t{8}\t{9}\t{10}\t{11}\t{12}\t{13}",
                                            cell,          
                                            addr.WorkSheet,
                                            addr.Column(),
                                            addr.Row(),
                                            cell.IsBlank,
                                            cell.IsFormula,
                                            cell.References.Count,
                                            cell.IsRange,
                                            cell.Formula,
                                            cell.Value,
                                            cell.ExcelNames.Count>0 ? cell.ExcelNames.Aggregate((acc,next) => acc+"|"+next) : "",
                                            cell.IsEvaluated,
                                            cell.IsEvaluated ? cell.EvaluatedValue : "",
                                            cell.References.Count> 0 ? cell.References.Aggregate("References:",(acc,next) => acc+"|"+next.KnownbyParentAs+"="+next.Cell.ToString()) : ""
                                            ));
            }

            return sb.ToString();
        }

        public void LoadResultsFrom(string resultsFName) {
            var results = ExtractionResults.LoadConfig<ExtractionResults>(File.ReadAllText(resultsFName));
            this.RootCell = results.rootCell;
            this.ProcessedCells = new ConcurrentDictionary<string, ExtractedCell>();
            foreach (ExtractedCell cell in results.ProcessedCells) {
                this.ProcessedCells.AddOrUpdate(cell.ToString(), cell, (key, value) => value);
            }
            foreach (KeyValuePair<string, ExtractedCell> cellPair in this.ProcessedCells) {
                foreach (CellReference cellReference in cellPair.Value.References) {
                    cellReference.Cell = this.ProcessedCells[cellReference.ReferenceName];
                }
            }
        }

        public XElement GetListXML() {
            XElement list = new XElement("Cell",
                                          new XAttribute("Name", "ROOT"));
            foreach (var cell in this.ProcessedCells.Values) {
                list.Add(cell.ToXml(false));
            }

            return list;
        }
    }
}